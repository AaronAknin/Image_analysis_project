# -*- coding: utf-8 -*-
"""FeatureExtraction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w77ar7ZPUB9_iviKjlKrvYDeY6dowq-1
"""

# Generate 2D Gabor filter

import numpy as np
import pylab
import cv2
import math
def Gabor(sigma, theta, Lambda, psi, gamma): # different with Gabor filter
    """Gabor feature extraction."""
    sigma_x = sigma
    sigma_y = float(sigma) / gamma

    # Bounding box
    nstds = 3  # Number of standard deviation sigma
    xmax = max(abs(nstds * sigma_x * np.cos(theta)), abs(nstds * sigma_y * np.sin(theta)))
    xmax = np.ceil(max(1, xmax))
    ymax = max(abs(nstds * sigma_x * np.sin(theta)), abs(nstds * sigma_y * np.cos(theta)))
    ymax = np.ceil(max(1, ymax))
    xmin = -xmax
    ymin = -ymax
    (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))

    # Rotation
    # Modulating function M: an oriented sinusoidal function
    x_theta = x * np.cos(theta) + y * np.sin(theta)
    y_theta = -x * np.sin(theta) + y * np.cos(theta)
    # Real part
    gb_real = np.exp(-.5 * (x_theta ** 2 / sigma_x ** 2 + y_theta ** 2 / sigma_y ** 2)) * np.cos(2 * np.pi / Lambda * x_theta + psi)
    # Imaginary Part
    gb_im = np.exp(-.5 * (x_theta ** 2 / sigma_x ** 2 + y_theta ** 2 / sigma_y ** 2)) * np.sin(2 * np.pi / Lambda * x_theta + psi)
    return gb

# Generate Ma defined filter: filter_Ma
# The first channel of spatial filters: filter_Ma_1
# For the frequency f, you can assign f as 1/deltaY. 
# You can also set f to 1/deltaX to compare the results.

def filter_Ma_1(theta):
    # delta_x = 3 and delta_y = 1.5 in paper Ma et al
    delta_x = 3
    delta_y = 1.5
    f = 1/delta_x
    # Bounding box
    nstds = 3  # Number of standard deviation sigma
    ## Set x,y using three sigma rule
    xmax = max(abs(nstds * delta_x * np.cos(theta)), abs(nstds * delta_y * np.sin(theta)))
    xmax = np.ceil(max(1, xmax))
    ymax = max(abs(nstds * delta_x * np.sin(theta)), abs(nstds * delta_y * np.cos(theta)))
    ymax = np.ceil(max(1, ymax))
    xmin = -xmax
    ymin = -ymax
    (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))

    # Modulating function M: a circularly symmetric sinusoidal function
    M = np.cos(2 * np.pi * f * np.sqrt(x ** 2 + y ** 2))
    fm = (1/(2 * np.pi * delta_x * delta_y)) * np.exp(-.5 * ((x / delta_x) ** 2 + (y / delta_y) ** 2)) * M
    return fm

# Generate Ma defined filter: filter_Ma
# The second channel of spatial filters: filter_Ma_2

def filter_Ma_2(theta):
    # delta_x = 4.5 and delta_y = 1.5
    delta_x = 4.5
    delta_y = 1.5
    f = 1/delta_x
    # Bounding box
    nstds = 3  # Number of standard deviation sigma
    xmax = max(abs(nstds * delta_x * np.cos(theta)), abs(nstds * delta_y * np.sin(theta)))
    xmax = np.ceil(max(1, xmax))
    ymax = max(abs(nstds * delta_x * np.sin(theta)), abs(nstds * delta_y * np.cos(theta)))
    ymax = np.ceil(max(1, ymax))
    xmin = -xmax
    ymin = -ymax
    (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))

    # Modulating function M: a circularly symmetric sinusoidal function
    M = np.cos(2 * np.pi * f * np.sqrt(x ** 2 + y ** 2))
    fm = (1/(2 * np.pi * delta_x * delta_y)) * np.exp(-.5 * ((x / delta_x) ** 2 + (y / delta_y) ** 2)) * M
    return fm

## Convolution

import matplotlib.pyplot as plt
import pylab
import cv2
import numpy as np

img = plt.imread('unnamed.png')
#I=cv2.imread(imagename) # Color image
I=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

plt.imshow(img)                                   
pylab.show()
# convolution and use f(0,1/delta_x))
# take theta in [0, pi/4, pi/2, 3*pi/4]
# take f in [1/delta_x, 1/de;ta_y]
F_1 = cv2.filter2D(I,-1,filter_Ma_1(0)) # take theta = 0
F_2 = cv2.filter2D(I,-1,filter_Ma_2(0)) # take theta = 0
# picture after convolution
plt.imshow(F_1)
pylab.show()
plt.imshow(F_2)
plt.imsave("F_1.png",F_1)
plt.imsave("F_2.png",F_2)
pylab.show()

F_1  # show the result

## 2D filter encode

### receive pictures from preprocessing part
### Here we need to get the size of image I (Iheight, Iwidth)
### I is a gray image
'''
I=cv2.imread(imagename)
I_height, I_width = I.shape
'''

v = []  ## feature vector
# encode filtered image
def filter_encode(imagename, filter): 
    # imagename can be chosen between F1 and F2
    # filter can be chosen in filter_Ma_1 and filter_Ma_2
    # filter_num = 2
    # print(I.shape)
    I_height= imagename.shape[0]
    I_width = imagename.shape[1]

    # filter size: set filter height and width, such as 9*9
    filter_height = 9
    filter_width = 9
    mmax = math.floor(I_height/filter_height)
    nmax = math.floor(I_width/filter_width)
    # for k in range(int(mmax * nmax)):
        
    for m in range(int(mmax)):
        for n in range(int(nmax)):
            # do partition from the image and compute inner product
            part_F = imagename[m*filter_height:(m+1)*filter_height, n*filter_width:(n+1)*filter_width]
            avg = np.mean(part_F)
            sigma = np.mean(part_F - avg)
            v.append(avg)
            v.append(sigma)
            
    print(v)  # feature vector
    # return v

'''
filter_encode(F_1, filter_Ma_1(0))
filter_encode(F_2, filter_Ma_1(0))
'''

